# 数据模型提取参考手册

> 本文档为 AI CPO Feature Design 的参考资料，在 Phase 3-4（竞品数据模型提取 + 自身数据模型设计）时加载。
> 来源: DDD (Eric Evans / Martin Fowler), Event Storming (Alberto Brandolini), Competitive Analysis

---

## 竞品数据模型提取方法

### 为什么要提取数据模型？

竞品的功能列表容易抄，但数据模型反映了**业务本质**。通过提取竞品的实体关系模型，可以发现：
- **行业共识**: 所有竞品都有的实体 = 核心业务概念
- **空白机会**: 没有竞品建模的实体 = 差异化源
- **设计模式**: 实体间的关系反映了业务流程的设计选择

### 三种提取方法

#### 方法 1: 从 API 文档提取

最准确的方法，适用于有公开 API 的竞品。

```
操作: WebSearch "{竞品名} API documentation" / "{竞品名} developer docs"
提取:
  - API 端点 → 实体名称（/users, /products, /orders → User, Product, Order）
  - 请求/响应字段 → 实体属性
  - 关联 ID 字段 → 实体关系（order.product_id → Order 属于 Product）
```

#### 方法 2: 从 UI 界面反推

适用于没有公开 API 的竞品。

```
操作: WebFetch 竞品主要页面
提取:
  - 导航菜单项 → 一级实体
  - 页面中的表格/列表 → 实体属性
  - 详情页中的关联链接 → 实体关系
  - 表单字段 → 实体的可编辑属性
  - 筛选条件 → 实体的索引属性
```

#### 方法 3: 从定价页面推断

核心洞察：**收费的东西 = 核心实体**。

```
操作: WebFetch 竞品定价页
提取:
  - 套餐限额项 → 核心实体（"最多 10 个项目" → Project 是核心实体）
  - 按量计费项 → 高频实体（"$0.01/次调用" → API Call 是事务实体）
  - 功能差异项 → 增值实体（"高级分析" → Analytics 是增值实体）
```

### 共性/空白分析表模板

```markdown
## 竞品数据模型共性分析

| 实体 | 竞品A | 竞品B | 竞品C | 共性 | 空白 |
|------|-------|-------|-------|------|------|
| User/Account | Y | Y | Y | 核心 | — |
| Product/Item | Y | Y | Y | 核心 | — |
| Order/Transaction | Y | Y | N | 多数 | 竞品C 无交易 |
| {AI 建议实体} | N | N | N | — | 全空白 = 机会 |

### 空白分析

| 空白实体 | 为什么没有竞品做 | 我们做的可行性 | 差异化价值 |
|---------|----------------|---------------|-----------|
| {实体名} | {分析原因} | {评估} | {价值判断} |
```

### 增补维度

除了实体模型，还需要从竞品提取：

| 维度 | 提取方法 | 设计价值 |
|------|---------|---------|
| **定价模型** | 定价页 + 用户评价中的价格讨论 | 定价策略参考 |
| **留存机制** | 产品内的复访触发（邮件、通知、仪表盘） | 留存设计参考 |
| **Onboarding 流程** | 注册试用竞品，记录前 5 分钟体验 | TTFV 设计参考 |

---

## 限界上下文设计指南

### 什么是限界上下文？

限界上下文（Bounded Context）是 DDD 的核心概念：**同一个词在不同上下文中含义不同时，就需要拆分上下文**。

### 何时拆分上下文

| 信号 | 说明 | 示例 |
|------|------|------|
| **同名异义** | 同一个词在不同场景含义不同 | "产品"在商品管理中 = SKU，在内容创作中 = 数字课程 |
| **独立生命周期** | 两组实体的创建/修改/删除彼此独立 | 用户资料 vs 订单记录 |
| **不同变化频率** | 一组实体频繁变化，另一组很少变 | 商品价格（频繁）vs 商品分类（偶尔） |
| **不同一致性要求** | 一组需要强一致性，另一组可以最终一致 | 支付（强一致）vs 推荐（最终一致） |

### 上下文间关系类型

| 关系 | 定义 | 适用场景 |
|------|------|---------|
| **共享内核**（Shared Kernel） | 两个上下文共享一组核心模型 | User 实体在多个上下文中使用 |
| **客户-供应商**（Customer-Supplier） | 上游上下文提供数据，下游消费 | 商品上下文提供数据 → 推荐上下文消费 |
| **各行其是**（Separate Ways） | 两个上下文完全独立 | 支付系统 vs 内容管理 |
| **防腐层**（Anti-corruption Layer） | 下游用翻译层隔离上游的模型 | 接入第三方 API 时用适配器 |

---

## AI 原生实体标注法

AI 原生实体 = **只因 AI 存在而存在的实体**。这些是 AI 产品的差异化源，需要重点投资。

### 判断标准

| 问题 | 回答"是" → |
|------|-----------|
| 如果去掉 AI，这个实体还有意义吗？ | 非 AI 原生 |
| 这个实体的核心价值来自 AI 生成/分析吗？ | AI 原生 |
| 竞品（非 AI 竞品）有这个实体吗？ | 非 AI 原生 |

### 标注模板

```markdown
## 实体清单

| 实体 | 类型 | 所属上下文 | AI 原生? | 说明 |
|------|------|-----------|---------|------|
| User | 核心 | 用户管理 | N | 所有产品都有 |
| Product | 核心 | 商品管理 | N | 电商基础实体 |
| AIStrategy | 价值 | AI 共创 | Y | AI 生成的商业策略，只因 AI 存在 |
| QualityScore | 辅助 | AI 评估 | Y | AI 对内容的质量评分 |
```

---

## 领域事件目录方法

来自 Event Storming：**名词 = 实体，动词 = 事件，事件驱动旅程**。

### 事件发现步骤

1. **描述业务流程**（用自然语言）
2. **提取动词** → 转为"已完成"时态 = 领域事件
3. **找事件的触发者** → 人? AI? 系统?
4. **找事件的影响** → 哪些实体的状态变了?
5. **排列时间线** → 形成事件流

### 事件模板

```markdown
## 领域事件目录

| 事件 | 触发者 | 输入实体 | 影响实体 | 上下文 |
|------|--------|---------|---------|--------|
| 用户注册完成 | 用户 | — | User | 用户管理 |
| AI 策略生成完成 | AI | User, BusinessGoal | Strategy | AI 共创 |
| 用户采纳策略 | 用户 | Strategy | ActionPlan | AI 共创 |
| 订单支付完成 | 系统 | Order | Payment, Delivery | 交易 |
```

---

## 参考来源

- Martin Fowler: [BoundedContext](https://martinfowler.com/bliki/BoundedContext.html)
- Alberto Brandolini: [Event Storming](https://www.eventstorming.com/)
- Qlerify: [Event Storming Guide](https://www.qlerify.com/blog/event-storming-guide)
- Eric Evans: [Domain-Driven Design Reference](https://www.domainlanguage.com/ddd/reference/)
