# 系统组件识别与分析方法

> 本文档在 Layer 4（系统组件）时加载。
> 来源: Domain-Driven Design, System Design Interview, Component-Based Architecture
> 层级对应: Layer 4 系统组件

---

## 组件识别方法

### 方法 1: 从 UI 反推组件

从用户看到的界面反推背后的系统组件。

```
页面 → 功能 → 组件 映射:

[页面/区域]           [功能]              [系统组件]
注册/登录页     →  身份验证          →  认证服务
仪表盘         →  数据聚合展示      →  聚合服务 + 数据库
编辑器         →  内容创建/编辑     →  内容管理服务 + 存储
预览           →  渲染展示          →  渲染引擎
设置页         →  配置管理          →  配置服务
支付页         →  支付处理          →  支付服务 + 第三方支付
AI 生成页面    →  AI 内容生成       →  AI 编排层 + 模型API
分析面板       →  数据分析          →  分析服务 + 数据管道
```

### 方法 2: 从 API 反推组件

从 API 端点推断后端服务组件。

```
API 端点 → 服务 → 组件 映射:

[API 前缀]            [服务]              [组件]
/auth/*          →  Auth Service     →  认证组件
/users/*         →  User Service     →  用户管理组件
/products/*      →  Product Service  →  产品管理组件
/orders/*        →  Order Service    →  订单处理组件
/ai/generate/*   →  AI Service       →  AI 编排组件
/files/*         →  File Service     →  文件存储组件
/webhooks/*      →  Event Service    →  事件处理组件
```

### 方法 3: 从技术需求推导组件

基于功能需求自底向上推导组件。

```
需求分解:
├── 用户要做什么？ → 核心组件
│   └── "创建网站" → 站点引擎、模板系统、编辑器
├── 系统要保证什么？ → 辅助组件
│   └── "安全访问" → 认证服务、权限管理
└── 运行依赖什么？ → 基础设施
    └── "数据持久化" → 数据库、缓存、文件存储
```

---

## 组件分类

| 类型 | 定义 | 判断标准 | 常见示例 |
|------|------|---------|---------|
| **核心组件** | 实现产品核心价值 | 去掉它产品就无法运作 | 站点引擎、编辑器、AI 生成 |
| **辅助组件** | 提供支撑能力 | 去掉它产品降级但可用 | 认证、权限、通知、分析 |
| **基础设施** | 运行时基础 | 所有应用都需要 | 数据库、缓存、CDN、队列 |

### 分类决策流程

```
对每个组件问:
├── 去掉它产品还能工作吗？
│   ├── 不能 → 核心组件
│   └── 能，但体验降级 → 继续
├── 它提供的是业务功能还是技术能力？
│   ├── 业务功能 → 辅助组件
│   └── 技术能力 → 基础设施
└── 它是这个产品独有的还是所有产品都需要的？
    ├── 独有 → 核心 或 辅助
    └── 通用 → 基础设施
```

---

## 组件卡片模板

对每个组件，填写以下卡片：

```
┌─────────────────────────────────────────┐
│ 组件: {名称}                             │
│ 类型: 核心 / 辅助 / 基础设施             │
├─────────────────────────────────────────┤
│ 解决的问题: {用一句话说明}               │
│                                          │
│ 输入:                                    │
│   - {数据/请求类型 1}                    │
│   - {数据/请求类型 2}                    │
│                                          │
│ 输出:                                    │
│   - {结果/响应类型 1}                    │
│   - {结果/响应类型 2}                    │
│                                          │
│ 关键决策:                                │
│   - {决策1}: {选项A} vs {选项B}          │
│     推荐: {选项}，因为 {理由}            │
│   - {决策2}: ...                         │
│                                          │
│ 交互:                                    │
│   → 调用: {它调用谁}                     │
│   ← 被调用: {谁调用它}                   │
│                                          │
│ 技术选型: {推荐的技术/框架}              │
├─────────────────────────────────────────┤
│ 来源: [源码 / API / UI / 设计]           │
└─────────────────────────────────────────┘
```

### 关键决策常见类型

| 决策类型 | 常见选项 | 决策依据 |
|---------|---------|---------|
| 同步 vs 异步 | 同步调用 / 消息队列 / 事件驱动 | 延迟要求、失败容忍度 |
| 容器 vs 进程 | Docker / 直接进程 / Serverless | 隔离需求、资源成本 |
| 实时 vs 批处理 | WebSocket / 轮询 / 定时任务 | 实时性要求、数据量 |
| 自建 vs 第三方 | 自己写 / SaaS / 开源库 | 控制权、成本、时间 |
| SQL vs NoSQL | PostgreSQL / MongoDB / DynamoDB | 数据结构、查询模式 |
| 缓存策略 | Redis / 内存 / CDN | 读写比、一致性要求 |
| 文件存储 | S3 / R2 / 本地 | 成本、CDN 集成、数据量 |

---

## 组件交互图规范

### ASCII 图标准

```
图例:
[组件名]     → 系统组件
──→          → 同步调用（请求-响应）
──▷          → 异步调用（发送-忘记）
- - →        → 可选调用（条件触发）
│            → 垂直连接
├──→ / └──→  → 分支调用
◆            → 数据存储
```

### 交互图绘制规则

1. **分层排列**: 用户 → 边缘 → 网关 → 服务 → 存储
2. **核心路径突出**: 最重要的调用路径放在中间
3. **标注数据**: 在箭头上标注传递的关键数据
4. **标注协议**: REST / GraphQL / gRPC / WebSocket / Message Queue

### 标准分层模板

```
                    [用户/客户端]
                         │
                         ▼
─────────────── 边缘层 ──────────────────
                    [CDN / 边缘函数]
                         │
─────────────── 网关层 ──────────────────
                    [API 网关 / BFF]
                         │
            ┌────────────┼────────────┐
            ▼            ▼            ▼
─────────── 服务层 ──────────────────────
     [服务A]      [服务B]      [服务C]
       │            │            │
       ▼            ▼            ▼
─────────── 数据层 ──────────────────────
     ◆ DB        ◆ Cache      ◆ Storage
```

### 典型交互模式

**模式 1: 同步请求-响应**
```
[客户端] ──→ [API] ──→ [服务] ──→ [数据库]
                                     │
[客户端] ←── [API] ←── [服务] ←─────┘
```

**模式 2: 异步任务**
```
[客户端] ──→ [API] ──→ [队列] ──▷ [Worker]
    │                               │
    │         [通知]  ←── ──── ────┘
    │            │
    └── 轮询 ──→ [状态 API]
```

**模式 3: 流式响应（AI 场景）**
```
[客户端] ──→ [API] ──→ [AI 编排] ──→ [模型 API]
    │                                    │
    │ ←── SSE/WebSocket ←── [流式转发] ←─┘
```

---

## 组件清单汇总模板

```markdown
### 组件清单

| # | 组件 | 类型 | 解决的问题 | 关键决策 | 技术选型 | 来源 |
|---|------|------|-----------|---------|---------|------|
| 1 | {组件A} | 核心 | {问题} | {决策} | {技术} | {来源} |
| 2 | {组件B} | 核心 | {问题} | {决策} | {技术} | {来源} |
| 3 | {组件C} | 辅助 | {问题} | {决策} | {技术} | {来源} |
| 4 | {组件D} | 基础设施 | {问题} | {决策} | {技术} | {来源} |

核心组件: {N} 个
辅助组件: {N} 个
基础设施: {N} 个
```

---

## 质量标准

### 组件分析最低要求

| 维度 | 最低标准 |
|------|---------|
| 核心组件数量 | ≥ 3 个 |
| 每个组件有完整卡片 | 问题/输入/输出/决策/交互 全填 |
| 组件交互图 | 至少 1 张完整的系统级交互图 |
| 关键决策有推理 | 每个决策有"为什么"，不只列选项 |
| 技术选型有理由 | 不只说"用 X"，要说"用 X 因为 Y" |
| 来源标注 | 每个组件标注信息来源 |

### 红线

- 不允许没有"解决的问题"的组件（每个组件必须有存在的理由）
- 不允许没有交互关系的孤立组件
- 技术选型不能只列名字，必须说明理由
