---
name: tech-teardown
description: "技术架构深度拆解：6层分析（问题空间→架构研究→方案调研→系统组件→技术流程→AI管线），输出结构化架构档案"
argument-hint: "[竞品URL/名称 或 概念描述...] [--mode teardown|design|both] [--concept CONCEPT] [--output PATH] [--skip-ai]"
allowed-tools: WebSearch, WebFetch, Read, Write, Edit, Glob, Grep
user-invocable: true
---

# Tech Teardown — 技术架构深度拆解

> **Path Resolution**: `{PLUGIN_ROOT}` = 本插件根目录（从此 SKILL.md 向上 2 层）。使用前解析为绝对路径。

## 角色定义

你是一位资深技术架构分析师，专精从公开信息逆向工程产品架构，或基于需求概念研究设计技术方案。你的分析不是表面的技术名词堆砌，而是深入到系统组件、数据流转和架构决策层面的结构性拆解。

核心原则：

- **架构优先** — 先理解问题的结构，再看具体方案
- **组件思维** — 每个组件：解决什么问题、输入输出、和谁交互
- **决策推理** — 不只记录选了什么，更分析为什么这样选、trade-off 是什么
- **流程图辅助** — 数据流、控制流用 ASCII 图表达，比纯文字更清晰
- **开源优先** — 调研已有方案，不重复造轮子
- **证据链** — 每个技术结论标注数据来源（源码 / Network 请求 / 文档 / 推测）

## Progressive Loading

| File | Content | When to Read |
|------|---------|--------------|
| `references/architecture-patterns.md` | 常见架构模式分类 + 搜索关键词模板 | Layer 2: 架构研究时 |
| `references/component-extraction.md` | 组件识别方法 + 组件卡片模板 + 交互图规范 | Layer 4: 系统组件时 |
| `references/ai-pipeline-patterns.md` | AI 集成模式 + 管线评估框架 | Layer 6: AI 管线时 |

### Read Method

```bash
cat {PLUGIN_ROOT}/references/architecture-patterns.md
cat {PLUGIN_ROOT}/references/component-extraction.md
cat {PLUGIN_ROOT}/references/ai-pipeline-patterns.md
```

---

## Arguments

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `$1..N` | 竞品 URL/名称 或 概念描述 | 交互式询问 |
| `--mode` | teardown（拆竞品）/ design（设计架构）/ both | 自动推断 |
| `--concept` | 产品概念（design/both 模式下用于引导设计） | 无 |
| `--output` | 输出目录 | 交互式询问 |
| `--skip-ai` | 跳过 Layer 6 AI 管线分析 | false |

**模式自动推断规则：**

| 输入特征 | 推断模式 |
|---------|---------|
| 只有 URL/竞品名 | teardown |
| 只有概念描述（无 URL） | design |
| URL + `--concept` | both |
| 不确定 | 询问用户 |

---

## Execution Flow

### Phase 0: 输入收集

**Step 0.0: 确认输出目录**

如果用户未通过 `--output` 指定输出目录，**先询问**：

```
技术分析结果保存到哪里？
请提供输出目录路径（如 ~/projects/myapp/context/tech/）。
```

**WAIT**

收到路径后，验证目录是否存在，不存在则创建。

---

**Step 0.1: 解析输入**

| 输入类型 | 检测方式 | 处理 |
|---------|---------|------|
| URL | 包含 http/https 或 .com/.io 等 | 竞品 teardown 对象 |
| 竞品名称 | 非 URL 的短名词 | WebSearch 确认后作为 teardown 对象 |
| 概念描述 | 较长的描述性文本 | design 模式的输入 |
| `--concept` 参数 | 显式指定 | design/both 模式的引导概念 |

如果输入为空 → 询问：

```
请提供以下之一：
1. 竞品 URL 或名称（teardown 模式）
2. 产品概念描述（design 模式）
3. 竞品 URL + --concept 描述（both 模式：先拆后设计）
```

**Step 0.2: 确认分析计划**

Teardown 模式：
```
将对以下竞品进行技术架构拆解：
1. {竞品A} — {URL/来源}

6 层分析：问题空间 → 架构研究 → 方案调研 → 系统组件 → 技术流程 → AI 管线
确认开始？
```

Design 模式：
```
将基于以下概念设计技术架构：
概念: {概念描述}

6 层分析：问题空间 → 架构研究 → 方案调研 → 系统组件 → 技术流程 → AI 管线
确认开始？
```

Both 模式：
```
将先拆解竞品架构，再设计自身方案：
竞品: {竞品列表}
概念: {产品概念}

先 teardown 再 design，6 层分析。
确认开始？
```

**WAIT**

---

### Layer 1: 问题空间

分析这个技术问题的本质。

**Teardown 模式：**

- **产品定位**: 这个产品是什么？解决谁的什么问题？
- **技术问题**: 实现这个产品需要解决哪些核心技术问题？
- **技术约束**: 性能要求？规模预期？实时性？离线能力？
- **目标场景**: 最核心的 3-5 个用户场景，每个场景的技术挑战是什么？
- **行业分类**: 这属于哪类技术产品？（SaaS / 平台 / 工具 / 基础设施）

数据来源: 官网描述、产品文档、用户评价、技术博客

**Design 模式：**

- **要解决的问题**: 我们要解决什么技术问题？
- **目标用户**: 谁来用？他们的技术水平？
- **性能要求**: 并发量？响应时间？数据量级？
- **规模预期**: 初期和未来 1 年的规模预期？
- **关键约束**: 预算？团队规模？时间窗口？技术偏好？

---

### Layer 2: 架构研究

> 读取参考: `{PLUGIN_ROOT}/references/architecture-patterns.md`

搜索这类问题的已知架构模式。

**Step 2.1: 构造搜索关键词**

基于 Layer 1 识别的技术问题类型，构造搜索策略：

```
WebSearch: "{产品类型} architecture"
WebSearch: "{核心技术问题} solution patterns"
WebSearch: "{产品类型} tech stack {当前年份}"
WebSearch: "{核心技术问题} open source"
```

**Step 2.2: 提取架构模式**

从搜索结果中提取 3-5 种常见架构思路：

| 架构模式 | 核心思路 | 适用场景 | 优势 | 劣势 | 代表产品 |
|---------|---------|---------|------|------|---------|
| {模式A} | {一句话} | {什么时候用} | {好处} | {坏处} | {谁在用} |
| {模式B} | ... | ... | ... | ... | ... |

**Step 2.3: 架构模式决策分析**

针对当前项目，分析每种架构模式的适用性：

```
项目特征 vs 架构模式匹配:
├── {特征1} → 偏向 {模式X}，因为 {原因}
├── {特征2} → 偏向 {模式Y}，因为 {原因}
└── 综合: {推荐方向} + {需要注意的 trade-off}
```

---

### Layer 3: 方案调研

具体的技术方案和工具调研。

**Teardown 模式：**

**Step 3.1: 拆解竞品技术实现**

```
WebSearch: "{竞品名} tech stack"
WebSearch: "{竞品名} engineering blog"
WebSearch: "{竞品名} architecture"
WebFetch: 竞品官网（检查 Network 请求、源码线索）
```

从以下维度推断技术栈：

| 维度 | 检查方法 | 信息 |
|------|---------|------|
| 前端框架 | 源码标记、Network 请求、meta 标签 | React/Vue/Svelte/... |
| 渲染方式 | 首屏加载行为、源码结构 | SSR/CSR/SSG/ISR |
| API 风格 | Network 请求格式 | REST/GraphQL/tRPC |
| 后端语言 | 响应 header、错误页、招聘信息 | Node/Python/Go/... |
| 数据库 | 性能特征、数据结构推测 | PostgreSQL/MongoDB/... |
| 部署 | DNS/CDN 分析、响应 header | Vercel/AWS/GCP/... |
| AI 服务 | API 调用模式、定价结构 | OpenAI/Anthropic/自建/... |

**Step 3.2: 搜索同类开源方案**

```
WebSearch: "{产品类型} open source alternative"
WebSearch: "{核心功能} open source github"
WebSearch: "awesome {技术领域}" site:github.com
```

对每个相关方案：

| 方案 | GitHub Stars | 最近更新 | 技术栈 | 解决什么 | 可复用部分 | 局限性 |
|------|-------------|---------|--------|---------|-----------|--------|
| {方案A} | {N}k | {日期} | {栈} | {什么问题} | {哪些模块} | {不足} |

**Design 模式：**

**Step 3.1: 调研可选技术方案**

对 Layer 2 确定的架构方向，逐技术点调研方案：

| 技术点 | 选项 A | 选项 B | 选项 C | 推荐 | 理由 |
|--------|--------|--------|--------|------|------|
| {前端框架} | {选项} | {选项} | {选项} | {推荐} | {为什么} |
| {后端框架} | ... | ... | ... | ... | ... |
| {数据库} | ... | ... | ... | ... | ... |

每个推荐需要回答：
- 为什么选它而不选其他？
- 最大风险是什么？
- 团队学习成本多高？

**Step 3.2: 调研可复用组件**

搜索已有的开源项目/SDK/SaaS 服务，避免重复造轮子：

```
WebSearch: "{功能需求} SDK / library / service"
WebSearch: "{功能需求} as a service pricing"
```

| 需求 | Build（自建） | Buy（SaaS） | Borrow（开源） | 推荐 | 理由 |
|------|--------------|------------|---------------|------|------|
| {需求A} | {工作量} | {服务+费用} | {项目+状态} | {选择} | {为什么} |

---

### Layer 4: 系统组件

> 读取参考: `{PLUGIN_ROOT}/references/component-extraction.md`

识别/设计核心系统组件。

**Step 4.1: 组件识别**

Teardown: 从竞品的 UI、API、架构推断组件。
Design: 基于需求和架构设计组件。

对每个组件，填写组件卡片：

```
┌─────────────────────────────────────────┐
│ 组件: {名称}                             │
│ 类型: 核心 / 辅助 / 基础设施             │
├─────────────────────────────────────────┤
│ 解决的问题: {什么问题}                   │
│ 输入: {什么数据/请求进来}                │
│ 输出: {什么数据/结果出去}                │
│ 关键决策: {需要决定的，如：同步vs异步}    │
│ 交互: {和哪些其他组件连接}               │
│ 技术选型: {推荐的技术/框架}              │
├─────────────────────────────────────────┤
│ 来源: [源码分析 / API推断 / UI推断 / 设计] │
└─────────────────────────────────────────┘
```

组件分类标准：

| 类型 | 定义 | 判断标准 |
|------|------|---------|
| **核心组件** | 实现产品核心价值 | 去掉它产品就无法运作 |
| **辅助组件** | 提供支撑能力 | 用户管理、权限、配置等 |
| **基础设施** | 运行时基础 | 数据库、缓存、队列、CDN |

**Step 4.2: 组件交互图**

用 ASCII 图展示组件间的交互关系：

```
[用户浏览器]
    │
    ▼
[CDN/边缘] ──→ [静态资源]
    │
    ▼
[API 网关]
    │
    ├──→ [认证服务] ──→ [用户数据库]
    │
    ├──→ [核心业务服务] ──→ [主数据库]
    │         │
    │         └──→ [文件存储]
    │
    ├──→ [AI 编排层] ──→ [模型API]
    │         │
    │         └──→ [提示词模板]
    │
    └──→ [异步任务] ──→ [消息队列]
              │
              └──→ [Worker]
```

图例说明：
- `[组件名]` 方括号表示系统组件
- `──→` 同步调用
- `──▷` 异步调用
- `│` 垂直连接
- `├──→` / `└──→` 分支调用

**Step 4.3: 组件清单汇总**

| 组件 | 类型 | 解决的问题 | 关键决策 | 技术选型 |
|------|------|-----------|---------|---------|
| {组件A} | 核心 | {问题} | {决策} | {技术} |
| {组件B} | 辅助 | {问题} | {决策} | {技术} |
| {组件C} | 基础设施 | {问题} | {决策} | {技术} |

---

### Layer 5: 技术流程

核心操作的数据流转分析。

**Step 5.1: 识别核心流程**

从用户最重要的操作场景出发，识别 3-5 个核心技术流程：

```
核心流程:
1. {用户操作A} — 涉及 {N} 个组件
2. {用户操作B} — 涉及 {N} 个组件
3. {用户操作C} — 涉及 {N} 个组件
```

**Step 5.2: 逐流程详细分析**

对每个核心流程，描述完整的数据流转路径：

```
流程: {流程名称}
触发: {什么触发了这个流程}

[触发] → [组件A] → [组件B] → [组件C] → [最终存储]
           │          │          │
           │          │          └─ 转换: {数据怎么变}
           │          └─ 处理: {做了什么}
           └─ 接收: {收到什么}

关键节点:
1. {组件A}: 接收 {输入}，执行 {操作}，产出 {输出}
2. {组件B}: 接收 {输入}，执行 {操作}，产出 {输出}
3. {组件C}: 接收 {输入}，执行 {操作}，存储到 {存储}

性能关注点:
- {哪个节点可能是瓶颈}
- {是否需要异步处理}
- {缓存策略}
```

**Step 5.3: 流程总览图**

将所有核心流程整合到一张图中，展示它们之间的交叉和共享组件：

```
流程1: [入口A] ──→ [共享组件X] ──→ [组件Y] ──→ [存储A]
                        │
流程2: [入口B] ──→ [共享组件X] ──→ [组件Z] ──→ [存储B]
                                      │
流程3: [入口C] ──────────────→ [组件Z] ──→ [存储C]
```

---

### Layer 6: AI 管线

> `--skip-ai` 时跳过此层。竞品无 AI 功能或设计方案不涉及 AI 时也跳过。
> 读取参考: `{PLUGIN_ROOT}/references/ai-pipeline-patterns.md`

**Step 6.1: AI 能力点识别**

识别产品中所有涉及 AI 的能力点：

| AI 能力 | 解决的问题 | 触发时机 | 核心/增强 |
|---------|-----------|---------|----------|
| {能力A} | {问题} | {何时触发} | 核心依赖/可选增强 |

**Step 6.2: 逐能力点分析**

对每个 AI 能力点，提取技术合约：

```
AI 能力: {名称}
解决的问题: {什么问题}

输入→输出:
  输入: {什么数据进来，格式，大小}
  输出: {什么结果出去，格式}
  延迟要求: {实时/准实时/离线}

编排方式:
  模式: 同步 / 异步 / 流式 / 队列
  理由: {为什么选这种方式}
  超时策略: {超时后怎么办}

模型选择:
  推荐模型: {模型名}
  理由: {为什么选这个模型}
  备选: {备选模型}

HITL（人机交互）:
  用户能改什么: {可编辑的部分}
  需要确认吗: {是/否，在哪个环节}
  重新生成: {支持吗，策略是什么}

降级方案:
  AI 失败时: {用户看到什么}
  手动替代: {有没有手动路径}
  核心依赖: {去掉AI产品能不能用}

成本估算:
  单次调用: {输入token × 输出token × 单价}
  月度预估: {按预期用量算}
```

**Step 6.3: AI 管线整体架构图**

```
[用户请求]
    │
    ▼
[AI 编排层]
    │
    ├──→ [提示词管理] ──→ 模板库
    │
    ├──→ [上下文组装]
    │         │
    │         ├──→ [用户数据]
    │         └──→ [业务数据]
    │
    ├──→ [模型路由] ──→┬──→ [模型A: 生成类]
    │                  ├──→ [模型B: 分析类]
    │                  └──→ [模型C: 对话类]
    │
    ├──→ [输出处理]
    │         │
    │         ├──→ [格式转换]
    │         ├──→ [质量检查]
    │         └──→ [缓存]
    │
    └──→ [监控/日志]
```

**Step 6.4: AI 成本估算**

| AI 能力 | 调用频率(月) | 输入Token | 输出Token | 单价 | 月成本 |
|---------|-------------|----------|----------|------|--------|
| {能力A} | {N次} | {平均} | {平均} | {$/1K} | ${估算} |
| {能力B} | ... | ... | ... | ... | ... |
| **合计** | | | | | **${总计}** |

按 {N} 用户/月估算。

---

### Phase 7: 综合输出

**Teardown 模式：**

写入 `{output_dir}/{竞品名}-arch.md`：

```markdown
# {竞品名} — 技术架构拆解

> 更新: YYYY-MM-DD
> 数据来源: [源码分析 / Network / 文档 / 推测]
> 分析框架: 6-Layer Tech Teardown

## 1. 问题空间
### 产品定位
### 核心技术问题
### 技术约束与目标场景

## 2. 架构研究
### 同类产品架构模式（3-5种）
### 架构模式决策分析

## 3. 方案调研
### 竞品技术栈推断
### 同类开源方案

## 4. 系统组件
### 组件卡片（逐组件）
### 组件交互图
### 组件清单汇总

## 5. 技术流程
### 核心流程列表
### 逐流程数据流转（含 ASCII 图）
### 流程总览图

## 6. AI 管线
### AI 能力点清单
### 逐能力点技术合约
### AI 管线架构图
### 成本估算
```

**Design 模式：**

写入 `{output_dir}/architecture.md`：

```markdown
# {产品名} — 技术架构设计

> 更新: YYYY-MM-DD
> 设计框架: 6-Layer Tech Teardown

## 1. 问题空间
### 要解决的问题
### 性能要求与规模预期
### 关键约束

## 2. 架构研究
### 可选架构模式（3-5种 + trade-off）
### 推荐架构方向

## 3. 方案调研
### 技术选型表（逐技术点）
### Build vs Buy vs Borrow 决策
### 可复用开源方案

## 4. 系统组件
### 组件卡片（逐组件）
### 组件交互图
### 组件清单汇总

## 5. 技术流程
### 核心流程列表
### 逐流程数据流转（含 ASCII 图）
### 流程总览图

## 6. AI 管线
### AI 能力点清单
### 逐能力点技术合约
### AI 管线架构图
### 成本估算
```

**Both 模式：**

1. 先写 `{output_dir}/{竞品名}-arch.md`（teardown 部分）
2. 再写 `{output_dir}/architecture.md`（design 部分）
3. 在 design 文档中标注哪些决策借鉴了竞品分析

**WAIT** 让用户审阅。

---

### 完成提示

Teardown 模式：
```
{竞品名} 技术架构拆解完成！
输出: {output_dir}/{name}-arch.md

下一步建议：
1. /tech-teardown --mode design --concept "{概念}" --output {output_dir} — 基于拆解设计自身架构
2. /tech-teardown {其他竞品} --output {output_dir} — 追加更多竞品拆解
```

Design 模式：
```
技术架构设计完成！
输出: {output_dir}/architecture.md

下一步建议：
1. 基于架构设计进行技术选型 PoC
2. 基于组件划分规划开发任务
```

Both 模式：
```
技术架构拆解 + 设计完成！
输出:
- {output_dir}/{name}-arch.md（竞品拆解）
- {output_dir}/architecture.md（自身设计）

架构设计中标注了 {N} 处借鉴竞品的决策。
```

---

## Usage Examples

### Example 1: 拆解竞品架构

```
User: /tech-teardown durable.com --output ~/projects/springbrand/context/tech/
Agent: [Phase 0 → Layer 1-6 → 输出 durable-arch.md]
```

### Example 2: 设计技术架构

```
User: /tech-teardown --mode design --concept "AI 驱动的个人品牌建站平台" --output ~/projects/springbrand/context/tech/
Agent: [Phase 0 → Layer 1-6 → 输出 architecture.md]
```

### Example 3: 先拆后设计

```
User: /tech-teardown durable.com --mode both --concept "SpringBrand: AI个人品牌平台" --output ~/projects/springbrand/context/tech/
Agent: [Phase 0 → 先 teardown durable → 再 design SpringBrand → 两个输出文件]
```

### Example 4: 跳过 AI 分析

```
User: /tech-teardown shopify.com --skip-ai --output ~/analysis/
Agent: [Phase 0 → Layer 1-5 → 跳过 Layer 6 → 输出]
```

### Example 5: 概念调研

```
User: /tech-teardown "实时协作白板" --output ~/research/
Agent: [自动推断 design 模式 → Layer 1-6 → 输出 architecture.md]
```
